#!/usr/bin/env ruby

require "normalize_country"
require "optparse"
require "tempfile"
require "fileutils"

class NormalizeXML
  def initialize(to, xpath)
    @to = to
    @xpath = xpath
  end

  def normalize(path)
    paths = File.directory?(path) ? Dir[ File.join(path, "*.xml") ] : [path]
    paths.each do |path|
      io = File.open(path)

      begin
        doc = REXML::Document.new(io)
        doc.get_elements(@xpath).each do |e|
          next unless e.text
          e.text = NormalizeCountry(e.text.strip, :to => @to)
        end

        tmp = Tempfile.new("normalize")
        doc.write(tmp)
        FileUtils.mv(tmp.path, path)
      ensure
        io.close
      end
    end
  end
end

class NormalizeDB
  def initialize(to, column)
    @to = to
    @table, @column = column.split(".", 2)
    raise "no database column given" if @column.nil? or @column.empty?
    @table = @table.to_sym
    @column = @column.to_sym
  end

  def normalize(dsn)
    rs = connect(dsn)
    rs.select(@column).distinct.each do |row|
      new_name = NormalizeCountry(row[@column], :to => @to)
      next unless new_name and new_name != row[@column]
      rs.where(@column => row[@column]).update(@column => new_name)
    end
  end

  def connect(dsn)
    db = Sequel.connect(dsn)
    raise "database has no table named '#@table'" unless db.table_exists?(@table)
    raise "database has no column named '#@table.#@column'" unless db[@table].columns.include?(@column)
    db[@table]
  end
end

class NormalizeCSV
  def initialize(to, column)
    @to = to
    @column = column
  end

  def normalize(path)
    paths = File.directory?(path) ? Dir[ File.join(path, "*.[tc]sv") ] : [path]
    paths.each do |path|
      # Name or A7      
      rows = CSV.read(path)
    end
  end
end

options = {}
OptionParser.new do |opts|
  opts.banner = "usage: #{File.basename($0)} [options] SOURCE"

  opts.on("-h", "--help", "Show this message") do
    puts opts
    exit 2
  end

  opts.on "-f", "--format FORMAT", "The format of SOURCE" do |format|
    options[:format] = format.to_sym
  end

  opts.on "-t", "--to CONVERSION", "Convert country names to this format (see docs for valid formats)" do |to|
    options[:to] = to
  end

  opts.on "-l", "--location LOCATION ", "The location of the conversion" do |source|
    options[:location] = source
  end
end.parse!

abort "source option required" unless ARGV.any?

missing = [:location, :format, :to].find { |opt| options[opt].nil? }
abort "#{missing} option required" if missing

klass = case options[:format]
  when :csv
    require "csv"
    NormalizeCSV
  when :db
    begin
      require "sequel"
    rescue LoadError => e
      abort "the db format requires Sequel, you can install it by running `gem install sequel`"
    end
    NormalizeDB
  when :xml
    require "rexml/document"
    NormalizeXML
  else
    abort "don't know how to normalize the format '#{options[:format]}'"
end

begin
  klass.new(options[:to], options[:location]).normalize(ARGV[0])
rescue => e
  abort "normalization failed: #{e}"
end
